package com.biz.a3;

import com.code5.fw.data.InitYaml;

/**
 * @author zero
 *
 *         인터페이스와 구현클래스가 1:1 관계일때는 인터페이스는 필요하지 않습니다.
 */
class A {

	void execute() {

		// 인터페이스와 구현클래스가 1:N 인 요구사항

		// 1) JDBC 드라이버, 컬랙션객체
		// - 이미 잘 만들어진 틀에서 사용만 하면 되고 인터페이스를 정의할 기회가 없음
		// - 한번 정한 인터페이스를 수정하는 비용은 큼
		// - 설계단계에서 인터페이스를 정하는 순간 사용자 요구사항은 반영 불가

		// 2) 이체 : A은행이체, B은행이체, C은행이체
		// - 인터페이스 결합 대상이 아님
		// - 인터페이스 사용보다 디자인패턴으로 해결 : 퍼사드패턴(구조), 미디에이터패턴(행위)
		// - 기능의 호출 MasterController.execute("A은행이체");

		// 3) 커피 : 카푸치노, 라떼, 아메리카노
		// - 아메리카노를 먼저 잘 만들고 카푸치노, 라떼를 재사용할 수 있을지 고민
		// - 잘 만든 코드를 가지고 추상화

		// 4) DAO, Service
		// 전부 1:1 관계
		// 바로 실행할 수 있는 코드를 개발자가 볼 수 있게 하는게 효과적

		// 낮은 결합도는 높은 개발비용이 필요함
		// 반대로
		// 높은 결합도는 상대적으로 낮은 개발비용 사용

		// 따라서 작동하는 SW를 위해선 내용 결합도를 사용하고
		// 파급효과가 발생했을때 코드 수정을 통해 문제를 해결하는 것이 현명

		// 빌드툴, CI/CD, 데브옵스
		// 개발자의 코드를 쉽게 배포하기 위한 노력

		// 내용 결합도를 사용 즉시 동작할 수 있는 코드를 쉽게 만들고

		// 교체의 요구사항에 따른 추상화가 필요할때 리펙토링을 통해

		// 스템프 또는 내용 결합으로 변경

		// 사례
		B 객체 = new B();

		객체.문제가있음();

		객체.잘만들어짐();
		객체.잘만들어짐(0);

		// 객체.민감한기능();
	}

}

class B {

	void 문제가있음() {
	}

	private int 잘만들어진기능에서사용하는데이터 = 0;

	int 잘만들어짐() {
		return 잘만들어진기능에서사용하는데이터++;
	}

	int 잘만들어짐(int i) {
		잘만들어진기능에서사용하는데이터 = i;
		잘만들어진기능에서사용하는데이터++;
		return 잘만들어진기능에서사용하는데이터;

	}

	////////////////////////////////////

	//abstract void 민감한기능();

	public static B createB() {

		boolean isDev = InitYaml.get().is("isDev");

		if (isDev) {
			return new BDvImpl();
		}

		return new BPrImpl();
	}

}

class BDvImpl extends B {

	void 민감한기능() {
		// stub : 다른 모듈의 테스트를 위해 만들어진 가상의 기능
	}

}

class BPrImpl extends B {

	void 민감한기능() {
		// 실제 기능
	}
}
